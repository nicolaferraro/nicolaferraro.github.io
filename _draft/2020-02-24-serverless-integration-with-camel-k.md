---
title:  "Serverless Integration with Camel K"
modified: 2020-02-24 12:30:00 +0100
last_modified_at: 2020-02-24 12:30:00 +0100
tags: [Knative, Apache Camel, Openshift, Kubernetes, Serverless, JBoss Fuse]
categories: [Dev]
header:
    image: post-logo-apache-camel-k-native.png
    teaser: post-logo-apache-camel-k-native.png
---

Apache Camel K is reaching its maturity with current 1.0.0-RC2 release, just one step away from 1.0.0.
We've been working hard in the past months to add awesome features to Camel K, but also to improve its stability
and performance. This post contains a list of cool stuff that you'll find in latest release.

First of all, if you're living under a rock and it's the first time you hear about Camel K, 
you can read some introductory blog posts here ([1](/2018/10/15/introducing-camel-k/), [2](/2018/10/15/camel-k-on-knative/))
or look at the [new Apache Camel website](https://camel.apache.org/) that contains a [Camel K section](https://camel.apache.org/camel-k/latest/)
with a lot of material that is automatically generated from the [Github repository](https://github.com/apache/camel-k).

## IDE integration

Camel K development style is minimalistic: you need just to write a single file with your integration routes and you can immediately 
run them on any Kubernetes cluster. This way of defining things is common to many FaaS platforms (although Camel K is not a proper FaaS platform, 
but a lightweight *integration* platform) and it's technically difficult to provide IDE support, such as code completion and other utilities, 
to developers.

But now we've it. The Red Hat integration tooling team has created some cool extensions for VS Code that make the development experience 
with Camel K even more exciting. 
You don't need to remember the Camel DSL syntax, the IDE will give you suggestions and error highlighting.

Code completion works with Java code, but it's not only limited to it: you also have suggestions and documentation out of the box when writing the Camel URIs and property files.
And you also have many options to run integrations and interact with them, all integrated in the IDE.

Just install the VS Code [Extension Pack for Apache Camel by Red Hat](https://marketplace.visualstudio.com/items?itemName=redhat.apache-camel-extension-pack) to have all these 
cool features available.

## Serverless

Serverless is the most important area where we're focusing the new developments in Apache Camel K, although, you should remember it, 
you can have a wonderful Camel K experience even without serverless features.
To enable the serverless profile in Camel K, you just need to have [Knative](https://knative.dev) installed.

In recent releases, we have added support for the most recent advancements in Knative, for example, Camel K is very well integrated 
with the **Knative event mesh** and you can easily produce or consume event from it.

With 2 lines of code you can transfer events (e.g. generated by IoT devices) from your MQTT broker to the mesh:

*bridge.groovy*
```groovy
from('paho:mytopic?brokerUrl=tcp://broker-address:1883&clientId=knative-bridge')
  .to('knative:event/device-event')
```

Not kidding, you just need to write those two lines of code in a file and run it with `kamel run bridge.groovy` to 
push data into the Knative broker. And you can also scale the Integration out (*Integration* is a Kubernetes custom resource, `oc get integrations` to see all them)
to have a higher throughput. Scaling here is manual because the source of events is a MQTT broker (but we've plans to put [auto-scaling also in this scenario](https://github.com/apache/camel-k/issues/1107)).

Auto-scaling works really well when you want to react to some Knative events:

*listener.groovy*
```groovy
from('knative:event/device-event')
  .to('http://myhost/webhook/random-id')
``` 

This integration scales automatically with the load because it is materialized into a [Knative Serving Service](https://knative.dev/docs/serving/spec/knative-api-specification-1.0/#service)
and automatically [subscribed to the Eventing Broker via a Trigger](https://knative.dev/docs/eventing/broker-trigger/).
It then receives a [CloudEvent](https://cloudevents.io/) when your IoT devices produce something and scales down to zero if there's no data coming.
You just need to create it (as before, just `kamel run listener.groovy`), all the remaining configuration is 
done dynamically by the Camel K operator.

We've added much more features for having a better integration with the Knative ecosystem and we've also fixed some compatibility and performance issues that were present 
in previous versions. The user experience is now much smoother.

If you are a Knative YAML developer (!), instead of using Camel K directly, you also have the option to use [Knative Camel Sources](https://knative.dev/docs/eventing/samples/apache-camel-source/)
which are part of the Knative release. They are wrappers for Camel K integrations that are compatible with all the tools used by Knative developers (such as the `kn` CLI or the OpenShift serverless console).
Sources in Knative can only push data into the various Knative endpoints, but not the other way around (i.e. they should not be used to publish data from Knative to the outside).
In Camel K you don't have this distinction: the Route is the fundamental building block of a Camel integration and you can do whatever you want with it. 

## Fast startup and low memory 

We cannot say we're serverless without mentioning the work that we're doing in improving the performance of the Camel K integrations.


Camel 3.1.0
Quarkus

## Fast build times

## Better CLI

## Master routes

## CronJobs

